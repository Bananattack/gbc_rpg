import re
import sys
import collections

class Error(Exception):
    def __init__(self, msg):
        Exception.__init__(self, msg)


DEFINITION_TYPES = ['byte', 'word', 'text']

def load_definition(input):
    input = file(input)
    result = collections.OrderedDict()
    linenum = 0

    def fail(msg):
        raise Error(input.name + ':' + str(linenum) + ': ' + msg)

    result['__types'] = list(DEFINITION_TYPES)
    result['__usertypes'] = []
    result['__typetypes'] = {}
    result['__defaults'] = []
    for line in input:
        linenum += 1
        line = line.strip()
        if line:
            if line.startswith('#'):
                continue
            data = line.split()
            if len(data) != 2:
                fail('Expected 2 arguments, but got ' + str(len(data)))
            attr, typename = data
            if typename == 'block':
                result['__name'] = attr
            elif typename.split('=')[0] in ('set', 'enum'):
                result['__types'].append(attr)
                result['__usertypes'].append(attr)
                result['__typetypes'][attr] = typename.split('=')[0]
                if len(typename.split('=')) == 2:
                    result['__defaults'].append(typename.split('=')[-1])
                else:
                    result['__defaults'].append(None)
            else:
                if typename not in result['__types']:
                    fail('Invalid type ' + typename + ' - must be in '
                        + repr(result['__types']))
                result[attr] = typename
    return result

def _get_definition_name(definition):
    if '__name' not in definition:
        block = [k for k, v in definition.iteritems() if v == 'block']
        if len(block):
            definition['__name'] = block[0]
        else:
            raise Error('Definition has no block element.')
    return definition['__name']

def load_data(input, definition):
    input = file(input)
    linenum = 0

    def fail(msg):
        raise Error(input.name + ':' + str(linenum) + ': ' + msg)

    items = []
    item = None
    for line in input:
        linenum += 1
        line = line.strip()
        if line:
            if line.startswith('#'):
                continue
            data = line.split(None, 1)
            key, value = data[0], data[1] if len(data) > 1 else True
            if key == 'end':
                items.append(item)
                item = None
            else:
                if key == definition['__name']:
                    item = {}
                    if value is not True:
                        item['name'] = value
                else:
                    if item is None:
                        fail('Attempt to set key "' + key + '" before starting a block.')
                    if key not in definition:
                        fail('Key "' + key + '" is not a valid attribute')                
                    item[key] = value
    if item:
        items.append(item)
    return items

def dump_repr(data, definition):
    return repr(data)

def _dump_c_preproc(data, definition):
    name = _get_definition_name(definition)
    result = '/* This file was autogenerated by robots! */\n'
    result += '#include <stdint.h>\n\n'
    result += '#define ' + name.upper() + 'S_TOTAL ' + str(len(data)) + '\n\n'

    for typename in definition['__usertypes']:
        n = 0
        for a, t in definition.items():
            if t == typename:
                typetype = definition['__typetypes'][typename]
                if typetype == 'set':
                    val = 1 << n
                elif typetype == 'enum':
                    val = n
                result += '#define ' + name.upper() + '_' + t.upper() + '_' + a.upper() + ' ' + str(val) + '\n'
                n += 1
        result += '\n'
    return result

def _convert_to_c_type(t):
    return {
        'byte': 'uint8_t',
        'word': 'uint16_t',
        'text': 'char const*'
    }.get(t)

def _convert_to_c_val(value):
    if type(value) is str:
        return '"' + value + '"'
    elif type(value) is int:
        return str(value)
    else:
        raise Error("Value in data was not string or integer type (" + type(value) + ").")

def dump_c_struct(data, definition):
    name = _get_definition_name(definition)
    result = _dump_c_preproc(data, definition)
    result += 'typedef struct\n{\n'

    usertypes = definition['__usertypes']
    for typename in usertypes:
        result += '    uint8_t ' + typename.lower() + ';\n'
    for a, t in definition.items():
        if not a.startswith('__') and t not in usertypes:
            result += '    ' + _convert_to_c_type(t) + ' ' + a.lower() + ';\n'
    result += '} ' + name.capitalize() + ';\n'
    result += '\n'

    result += name.capitalize() + ' const ' + name.lower()
    result += 's[' + name.upper() + 'S_TOTAL] = {\n'
    values = []
    for item in data:
        value = [list() for i in range(len(usertypes))]
        for a, t in definition.items():
            if t in usertypes:
                if item.get(a):
                    value[usertypes.index(t)].append(name.upper() + '_' + t.upper() + '_' + a.upper())
            elif not a.startswith('__'):
                value.append(_convert_to_c_val(item.get(a, 0)))
               
        for i in range(len(usertypes)):
            typetype = definition['__typetypes'][usertypes[i]]
            if typetype == 'set':
                value[i] = ' | '.join(value[i]) or (name.upper() + '_' + t.upper() + '_' + definition['__defaults'][i].upper() if definition['__defaults'][i] else '0')
            elif typetype == 'enum':
                value[i] = value[i][0]
        values.append('    {' + ', '.join(value) + '}')
    result += ',\n'.join(values) + '\n};'
    return result

def dump_c_array(data, definition):
    name = _get_definition_name(definition)
    result = _dump_c_preproc(data, definition)
    usertypes = definition['__usertypes']

    first = True
    for typename in usertypes:
        values = []
        for item in data:
            value = []
            for a, t in definition.items():
                if t == typename and item.get(a):
                    value.append(name.upper() + '_' + t.upper() + '_' + a.upper())
            i = usertypes.index(typename)
            typetype = definition['__typetypes'][typename]
            if typetype == 'set':
                value = ' | '.join(value) or (name.upper() + '_' + t.upper() + '_' + definition['__defaults'][i].upper() if definition['__defaults'][i] else '0')
            elif typetype == 'enum':
                value = value[0]
            values.append(value)

        result += ('' if first else '\n\n') + 'uint8_t const ' + name.lower() + '_' + typename.lower() + 's[' + name.upper() + 'S_TOTAL] = {\n' \
                + '    ' \
                + ',\n    '.join(values) \
                + '\n};'
        first = False

    for a, t in definition.items():
        if not a.startswith('__') and t not in usertypes:
            result += ('' if first else '\n\n') + _convert_to_c_type(t) + ' const ' + name.lower() + '_' + a.lower() + 's[' + name.upper() + 'S_TOTAL] = {\n' \
                + '    ' \
                + ',\n    '.join([_convert_to_c_val(item.get(a, 0)) for item in data]) \
                + '\n};'
            first = False

    return result

def _dump_z80_equ(data, definition):
    name = _get_definition_name(definition)
    result = '; This file was autogenerated by robots! \n'
    result += name.upper() + 'S_TOTAL EQU ' + str(len(data)) + '\n\n'

    for typename in definition['__usertypes']:
        n = 0
        for a, t in definition.items():
            if t == typename:
                typetype = definition['__typetypes'][typename]
                if typetype == 'set':
                    val = 1 << n
                elif typetype == 'enum':
                    val = n
                result += name.upper() + '_' + t.upper() + '_' + a.upper() + ' EQU ' + str(val) + '\n'
                n += 1
        result += '\n'
    return result

def dump_z80(data, definition):
    name = _get_definition_name(definition)
    result = _dump_z80_equ(data, definition)
    usertypes = definition['__usertypes']

    first = True
    for typename in usertypes:
        values = []
        for item in data:
            value = []
            for a, t in definition.items():
                if t == typename and item.get(a):
                    value.append(name.upper() + '_' + t.upper() + '_' + a.upper())
            i = usertypes.index(t)
            typetype = definition['__typetypes'][typename]
            if typetype == 'set':
                value = ' | '.join(value) or (name.upper() + '_' + t.upper() + '_' + definition['__defaults'][i].upper() if definition['__defaults'][i] else '0')
            elif typetype == 'enum':
                value = value[0]
            values.append(value)

        result += ('' if first else '\n') + name.lower() + '_' + typename.lower() + 's:\n' \
                + '    DB ' \
                + '\n    DB '.join(values) \
                + '\n'
        first = False

    for a, t in definition.items():
        if not a.startswith('__') and t not in usertypes:
            result += ('' if first else '\n') + name.lower() + '_' + a.lower() + 's:\n'
            values = []
            for item in data:
                if t == 'byte':
                    values.append('DB ' + str(item.get(a, 0)))
                elif t == 'word':
                    values.append('DW ' + str(item.get(a, 0)))
                elif t == 'text':
                    item_name = re.sub(r'[^a-z0-9_]*', '', re.sub(' ', '_', item['name'].lower()))
                    values.append('DW ' + name.lower() + '_' + a.lower() + '_' + item_name + '_text')
            result += '    ' + '\n    '.join(values) + '\n'
            first = False

    return result    

def dump_texts(data, definition):
    name = _get_definition_name(definition)
    usertypes = definition['__usertypes']

    result = ['# This file was was autogenerated by robots!']
    for a, t in definition.items():
        if not a.startswith('__') and t == 'text':
            values = []
            for item in data:
                item_name = re.sub(r'[^a-z0-9_]*', '', re.sub(' ', '_', item['name'].lower()))
                values.append(name.lower() + '_' + a.lower() + '_' + item_name + '_text: ' + re.sub(' ', '_', item.get(a, '')))
            result.extend(values)
    return '\n'.join(result)

DUMPERS = {
    'repr': dump_repr,
    'c_struct': dump_c_struct,
    'c_array': dump_c_array,
    'z80': dump_z80,
    'texts': dump_texts,
}

class Dat(object):
    def __init__(self, data, definition):
        self.data = data
        self.definition = definition

    def read_definition(self):
        if type(self.definition) is str:
            self.definition = load_definition(self.definition)
        return self.definition

    def read_data(self):
        if type(self.data) is str:
            self.data = load_data(self.data, self.read_definition())
        return self.data

    def read(self):
        return self.read_data()

    def dump(self, format='repr'):
        data, definition = self.read_data(), self.read_definition()
        if format not in DUMPERS:
            raise Error('Invalid format ' + repr(format) + ', must be in ' +
                repr(DUMPERS.keys())
            )
        return DUMPERS[format](data, definition)